---
title: "MySQL面试题"
date: 2024-09-14
description: ""
cover: https://github.com/Gjt-9520/MarkDownBlog/blob/main/source/coverImages/Bimage-135/Bimage130.jpg?raw=true
tags: ["MySQL"]
category: "面试"
updated: 2024-09-15
  
top_group_index: 
---

# MySQL的深度分页如何优化？

1. 基于主键或唯一索引优化

通过记录id，记录上一次查询的最大id（或其他唯一标识符），并以此为起点进行下一次查询。

这种方法需要又连续的唯一的列（如自增id）以用于分页。

2. 使用子查询优化

通过子查询的方式，仅选择需要的记录id，然后再通过这些id去查询完整的数据。

3. 通过覆盖索引

确保分页操作使用的查询能够被覆盖索引满足，以减少回表的次数。

4. 借助其他缓存

通过Redis或者ES，将分页的结果缓存，避免重复查询。

5. 限制最大页数

限制最大的可翻页页数，避免用户访问深度分页。

# truncate、delete、drop的区别？

1. truncate删除所有数据，但保留表结构。

性能比delete快，不记录单独的行删除操作，也不触发行级触发器。

作为DDL，不能被回滚。

自动递增的值会被重置。

2. delete删除指定行或所有数据，但保留表结构和约束。

逐行记录行删除操作，激活行级触发器。

作为DML，支持事务处理，可以在事务中回滚。

自动递增的值会被保留。

3. drop删除整张表、数据库或其他数据库对象，包括表结构和约束。

立即操作，不可恢复。

作为DDL，不能被回滚。

# 索引失效的情况？

1. 联合索引中出现范围查询，索引失效

2. 索引列上进行计算，索引失效

3. 字符串不加引号，索引失效

4. 头部模糊匹配，索引失效

5. or的连接条件中不全有索引，索引失效

6. MySQL评估使用索引比全表更慢，索引失效

# 锁有哪些？

1. 行级锁（RowLock）

仅对特定的行加锁，允许其他事务并发访问不同的行，适用于高并发场景。

2. 表级锁（Table Lock）

对整个表加锁，其他事务无法对该表进行任何读写操作，适用于需要保证完整性的小型表。

3. 意向锁（lntentionLock）

一种表锁，用于表示某个事务对某行数据加锁的意图，分为意向共享锁（IS）和意向排它锁（IX），主要用于行级锁与表级锁的结合。

4. 共享锁（SharedLock）

允许多个事务并发读取同一资源，但不允许修改。只有在释放共享锁后，其他事务才能获得排它锁。

5. 排它锁（ExclusiveLock）

只允许一个事务对资源进行读写，其他事务在获得排它锁之前无法访问该资源。

6. 元数据锁（MetadataLock,MDL）

用于保护数据库对象（如表和索引）的元数据，防止在进行DDL操作时其他事务对这些对象进行修改。

7. 间隙锁（GapLock）

针对索引中两个记录之间的间隙加锁，防止其他事务在这个间隙中插入新记录，以避免幻读。间隙锁不锁定具体行，而是锁定行与行之间
的空间。

8. 临键锁（Next-KeyLock）

是行级锁和间隙锁的结合，锁定具体行和其前面的间隙，确保在一个范围内不会出现幻读。常用于支持可重复读的隔离级别。

9. 插入意向锁（InsertIntentionLock）

一种特殊的意向锁，用于指示事务打算在某个间隙中插入记录，允许其他事务进行共享锁，但在插入时会阻止其他的排它锁。

10. 自增锁（AutoIncrementLock）

在插入自增列时，加锁以保证自增值的唯一性，防止并发插入导致的冲突。通常在插入操作时被使用，以确保生成的自增ID是唯一的。

# 三大范式？

1. 第一范式（1NF：First Normal Form）

定义：确保表中的每一列都是原子的，即不可再分。

2. 第二范式（2NF：Second Normal Form）

定义：在满足第一范式的基础上，确保表中的非主键列完全依赖于主键。

3. 第三范式（3NF：Third Normal Form）

定义：在满足第二范式的基础上，确保表中的非主键列不依赖于其他非主键列。

# MySQL的ChangeBuffer是什么？它有什么作用？

ChangeBuffer是MySQLInnoDB存储引擎中的一个机制，用于暂存对二级索引的插入和更新操作的变更，而不立即执行这些操作，随后，
当InnoDB进行合适的条件时（如页被读取或Flush操作），会将这些变更写入到二级索引|中。

# 一条SQL语句的执行过程？

1. 先通过连接器校验权限

2. 利用分析器进行SQL语句的词法分析和语法分析，构建解析树

3. 使用优化器选择合适的索引和表连接顺序，最终选择一个最佳的执行计划

4. 利用执行器，调用引擎层查询数据，返回结果集给客户端

# MySQL的主要存储引擎？

1. InnoDB:

支持事务、行级锁和外键。

提供高并发性能，适用于高负载的OLTP应用。

数据以聚集索引的方式存储，提高检索效率。

2. MyISAM:

不支持事务和外键，使用表级锁。

适合读取多、更新少的场景，如数据仓库。

具有较高的读性能和较快的表级锁定。

# 索引有哪些？
 
1. 按【数据结构】分类：B+树索引，hash索引

2. 按【物理存储】分类：聚簇索引，非聚簇索引(二级索引、辅助索引)

3. 按【字段特性】分类：主键索引、唯一索引、前缀索引

# 聚簇索引和非聚簇索引的区别？

1. 聚簇索引：

索引叶子结点存储的是数据行，可以直接访问完整数据。

每个表只能有一个聚簇索引，通常是主键索引，适合范围查询和排序。

2. 非聚簇索引：

索引叶子节点存储的是数据行的主键和对应的索引列，需通过主键才能访问完整的数据行。

一个表可以有多个非聚簇索引（称之为非主键索引、辅助索引、二级索引），适用于快速查找特定列的数据。

# 什么是回表？

回表是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数
据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，这个过程被称为回表。

# 什么是最左前缀匹配原则？

MySQL索引的最左前缀匹配原则指的是在使用联合索引时，查询条件必须从索引的最左侧开始匹配。如果一个联合索引包含多个列，查询条
件必须包含第一个列的条件，然后是第二个列，以此类推。

# 什么是覆盖索引？

MySQL的覆盖索引（CoveringIndex）是指二级索引中包含了查询所需的所有字段，从而使查询可以仅通过访问二级索引而不需要访问实际
的表数据（主键索引）。

# 什么是索引下推？

索引下推就是

通过二级索引查到主键id后回表完再进行where条件过滤 

改为=> 

二级索引查到数据后直接where过滤一遍再进行回表，减少回表的次数。

# 构建索引注意事项？

1. 不能盲目的建立索引，索引并不是越多越好，索引会占用空间，且每次修改的时可能都需要维护索引的数据，消耗资源。

2. 对于字段的值有大量重复的不要建立索引。比如说：性别字段，在这种重复比例很大的数据行中，建立索引也不能提高检索速度。但是也
不绝对，例如定时任务的场景，大部分任务都是成功，少部分任务状态是失败的，这时候通过失败状态去查询任务，实际上能过滤大部分成功
的任务，效率还是可以的。

3. 对于一些长字段不应该建立索引。比如text、longtext这种类型字段不应该建立索引。因为占据的内存大，扫描的时候大量加载至内存中
还耗时，使得提升的性能可能不明显，甚至可能还会降低整体的性能，因为别的缓存数据可能因为它被踢出内存，下次查询还需要从磁盘中获
取。

4. 当数据表的修改频率远大于查询频率时，应该好好考虑是否需要建立索引。因为建立索引会减慢修改的效率，如果很少的查询较多的修
改，则得不偿失。

5. 对于需要频繁作为条件查询的字段应该建立索引。在where关键词后经常查询的字段，建立索引能提高查询的效率，如果有多个条件经常
一起查询，则可以考虑联合索引，减少索引数量。

6. 对经常在 order by、group by、distinct 后面的字段建立索引。这些操作通常需要对结果进行排序、分组或者去重，而索引可以帮助加快
这些操作的速度。

# MySQL中B+树查询数据的过程？

首先从根节点开始，逐层搜索，直到找到叶子节点，即对应的数据页。在确定了待查找数据就存在于这个数据页上之后，我们将这个
数据页加载到内存，通过页目录做二分查找，定位出一个粗略的记录分组，最后在这个分组里通过链表遍历的方式来找到指定记录
行。

# 为什么采用B+树作为索引的数据结构？

1. 首先B+树是自平衡树，不需要维护树的平衡而消耗性能

2. B+树是一个多叉树，在相同数据的情况下，B+树的层级更低，层级低就减少了磁盘的IO次数

3. B+树的数据存储在叶子节点中，节点之间采用链表进行连接，也便于范围查找

# MySQL如何实现事务？

MySQL主要是通过：锁、RedoLog、UndoLog、MVcC来实现事务。

MySQL利用锁（行锁、间隙锁等等）机制，使用数据并发修改的控制，满足事务的隔离性。

RedoLog（重做日志），它会记录事务对数据库的所有修改，在崩溃时恢复未提交的更改，用来满足事务的持久性。

UndoLog（回滚日志），它会记录事务的反向操作，简单地说就是保存数据的历史版本，用于事务的回滚，使得事务执行失败之后可以恢复之前的样子。实现原子性和隔离性。

MVCC（多版本并发控制），满足了非锁定读的需求，提高了并发度，实现了读已提交和可重复读两种隔离级别，实现了事务的隔离性。

其实事务主要是为了实现一致性，具体是通过AID，即原子性、隔离性和持久性来达到一致性的目的。

# 长事务导致哪些问题？

长事务：执行的时间太长

1.造成阻塞

2.主从延迟（长时间主从数据库数据不一致）

3.执行过程中如果失败回滚，代价高

解决方案：

1.拆分长事务（同时执行，提高效率）

2.建立索引（没有索引的情况）

3.转换思路（删除大量数据，转换成把剩余少部分数据插入新表，最后再删除旧表）

# 什么是MVCC？

MVCC（Multi-VersionConcurrency Control，多版本并发控制）是一种并发控制机制，允许多个事务同时读取和写入数据库，而无需互相
等待，从而提高数据库的并发性能。

在MVCC中，数据库为每个事务创建一个数据快照。每当数据被修改时，MySQL不会立即覆盖原有数据，而是生成新版本的记录。每个记录都保留了对应的版本号或时间戳。

多版本之间串联起来就形成了一条版本链，这样不同时刻启动的事务可以无锁地获得不同版本的数据(普通读)。此时读(普通读)写操作不会阻塞。

写操作可以继续写，无非就是会创建新的数据版本（但只有在事务提交后，新版本才会对其他事务可见。未提交的事务修改不会影响其他事务的读取），历史版本记录可供已经启动的事务读取。

# 如果没有MVCC，会出现什么问题？

1. 没有MVCC，数据库通常采用行锁或表锁来控制并发。多个事务在执行时需要获取锁，导致事务之间存在竞争，降低了系统的并发处理能力。

2. 在较高的并发场景下，事务可能会因为等待锁而被阻塞，从而延长用户请求的响应时间。

3. 脏读：一个事务可能会读取到另一个尚未提交的事务所做的更改。

4. 不可重复读：在一个事务中，如果两次读取相同数据时，另一个事务对该数据做了更改，导致第一次和第二次读取到的数据不同。

5. 幻读：在一个事务中，当查询的数据行数量发生变化（如另一事务插入了新行）时，可能导致同一查询在不同时间返回不同的结果。

6. 高并发情况下，事务之间的相互影响会导致最终数据状态的不可预测性，从而破坏数据一致性。

7. 在没有MVCC的情况下，实施高隔离级别（如可重复读或序列化）需要依赖严密的锁策略，这可能会大大降低系统的性能。

# MySQL的隔离级别？

1. 读未提交（Read Uncommit）

一个事务可以看到另一个事务未提交的数据修改。

会出现脏读、幻读、不可重复读问题。

2. 读已提交（Read commit）

一个事务可以看到另一个事务已提交的数据修改。

会出现幻读、不可重复读问题。

3. 可重复读（Repeatable Read）

确保一个事务多次查询的结果一致。

会出现幻读问题。

4. 串行化（Serializable）

每一个事务都会等待前一个事务执行完毕才会执行。

# 脏读、不可重复读、幻读是什么？

1. 脏读（DirtyRead）

一个事务读取到另一个事务未提交的数据。

如果该未提交事务最终被回滚，那么第一个事务读取的数据就是不一致的（脏的）。

2. 不可重复读（Non-repeatableRead）

在同一事务中，读取同一数据两次，但由于其他事务的提交，读取的结果不同。

例如，事务A读取了一行数据，事务B修改并提交了这行数据，导致事务A再次读取时得到不同的值。

3. 幻读（Phantom Read）

在同一事务中，执行相同的查询操作，返回的结果集由于其他事务的插入而发生变化。

例如，事务A查询符合某条件的记录，事务B插入了新记录并提交，导致事务A再次查询时看到不同的记录数量。

# 当前读、快照读是什么？

1. 当前读（Current Read）

读取最新的数据，加锁，适用于更新操作和显式锁定。

`select ... for update;`或者`select ... lock in share mode;`

2. 快照读（Snapshot Read）

读取事务开始时的数据库快照，不加锁，适用于查询操作，提高并发性能。

隔离级别下：

Read Commit：每次select都会产生一个快照读。

Repetable Read：开启事务后的第一个select才会产生一个快照读。

Serializable：没有快照读，每次select都是当前读。

# 发生死锁，怎么办？

1. 自动检测与回滚

MySQL自带死锁检测机制（innodb_deadlock_detect），当检测到死锁时，数据库会自动回滚其中一个事务，以解除死锁。通常会回滚事务中持有最少资源的那个。

也有锁等待超时的参数（innodb_lock_wait_timeout），当获取锁的等待时间超过阈值时，就释放锁进行回滚。

2. 手动kill发生死锁的语句

可以通过命令，手动快速地找出被阻塞的事务及其线程ID，然后手动kill它，及时释放资源。

# 如何使用MySQL的EXPLAIN语句进行查询分析？

EXPLAIN属性：

1. id：查询的执行顺序的标识符，值越大优先级越高。简单查询的id 通常为1，复杂查询（如包含子查询或UNION）的id 会有多个。

2. select_type（重要）：查询的类型，如 SIMPLE（简单查询）、PRIMARY（主查询）、SUBQUERY（子查询）等。

3. table：查询的数据表。

4. type（重要）：访问类型，如 ALL（全表扫描）、index（索引扫描）、range（范围扫描）等。一般来说，性能从好到差的顺序是：

const > eq_ref > ref > range > index > ALL。

5. possible_keys：可能用到的索引l。

6. key（重要）：实际用到的索引l。

7. key_len：用到索引l的长度。

8. ref：显示索引的哪一列被使用。

9. rows（重要）：估计要读取的行数，值越小越好。

10. filtered：显示查询条件过滤掉的行的百分比。一个高百分比表示查询条件的选择性好。

11. Extra（重要）：额外信息，如Using index（表示使用覆盖索引）、Using where（表示使用 WHERE条件进行过滤）、Using

12. temporary（表示使用临时表）、Usingfilesort（表示需要额外的排序步骤）。

# MySQL中count(*).count(1）和count（字段名）有什么区别？

1. count(*)，是用来统计有多少列的，包括null

2. count(1)和count(*)一样，都是用来统计有多少列的

3. count（字段名)是用来统计包含该字段的字段有多少列，字段不为null

# 





