---
title: "索引"
date: 2024-05-14
description: ""
cover: https://github.com/Gjt-9520/Resource/blob/main/Bimage-135/Bimage16.jpg?raw=true
tags: ["MySQL"]
category: "学习笔记"
updated: 2024-05-15
swiper_index: 
top_group_index: 
---

# 索引

索引(index)是**帮助MySQL高效获取数据的数据结构(有序)**           

在数据之外,数据库系统还维护着满足特定查找算法的数据结构,这些数据结构以某种方式引用(指向)数据,这样就可以在这些数据结构上实现高级查找算法,这种数据结构就是索引

优缺点:

![索引优缺点](../images/索引优缺点.png)

# 结构

MySQL的索引是在存储引擎层实现的,不同的存储引擎有不同的索引结构,主要包含以下几种:

![索引结构](../images/索引结构.png)

存储引擎支持情况:

![存储引擎支持情况](../images/存储引擎支持情况.png)

细节:**如果没有特别指明,都是指B+树结构组织的索引**

## B+树索引

MySQL索引数据结构对经典的B+Tree进行了优化            

在原B+Tree的基础上,增加一个指向相邻叶子节点的链表指针,就形成了带有顺序指针的B+Tree,提高区间访问的性能,利于排序

![MySQL中的B+树范例](../images/MySQL中的B+树范例.png)

## Hash索引

哈希索引就是采用一定的hash算法,将键值换算成新的hash值,映射到对应的槽位上,然后存储在hash表中

如果两个(或多个)键值,映射到一个相同的槽位上,他们就产生了hash冲突(也称为hash碰撞),可以通过链表来解决

![MySQL中的Hash索引范例](../images/MySQL中的Hash索引范例.png)

### 特点

1. Hash索引只能用于对等比较(`=`,`in`),不支持范围查询(`between`,`>`,`<`,...)
2. 无法利用索引完成排序操作
3. 查询效率高,通常(不存在hash冲突的情况)只需要一次检索就可以了,效率通常要高于B+tree索引

### 存储引擎支持

在MySQL中,支持hash索引的是Memory存储引擎                 
而InnoDB中具有自适应hash功能,hash索引是InnoDB存储引擎根据B+Tree索引在指定条件下自动构建的

思考:**为什么InnoDB存储引擎选择使用B+tree索引结构?**

1. 相对于二叉树,层级更少,搜索效率高
2. 相对于B-tree,无论是叶子节点还是非叶子节点,都会保存数据,这样导致一页中存储的键值减少,指针跟着减少,要同样保存大量数据,只能增加树的高度,导致性能降低
3. 相对于Hash索引,B+tree支持范围匹配及排序操作

# 分类

![索引分类1](../images/索引分类1.png)

在InnoDB存储引擎中,根据索引的存储形式,又可以分为以下两种

![索引分类2](../images/索引分类2.png)

聚集索引选取规则:
1. 如果存在主键,主键索引就是聚集索引
2. 如果不存在主键,将使用第一个唯一(UNIQUE)索引作为聚集索引
3. 如果表没有主键,或没有合适的唯一索引,则InnoDB会自动生成一个rowid作为隐藏的聚集索引

聚集索引和二级索引的具体结构范例:

![聚集索引和二级索引的具体结构范例](../images/聚集索引和二级索引的具体结构范例.png)

## 范例

回表查询:先到二级索引中查找数据,找到主键值,再到聚集索引中根据主键值,获取数据的方式

当执行如下的SQL语句时,具体的查找过程:

![具体的查找过程](../images/根据索引具体的查找过程.png)

1. 由于是根据name字段进行查询,所以先根据name='Arm'到name字段的二级索引中进行匹配查找,但是在二级索引中只能查找到Arm对应的主键值10  
2. 由于查询返回的数据是*,所以此时,还需要根据主键值10,到聚集索引中查找10对应的记录,最终找到10对应的行row
3. 最终拿到这一行的数据,直接返回即可

## 思考

1. 以下两条SQL语句,那个执行效率高?为什么?

A.`select * from user where id = 10 ;`                
B.`select * from user where name = 'Arm' ;`               
备注: id为主键,name字段创建的有索引             

解答:A语句的执行性能要高于B语句,因为A语句直接走聚集索引,直接返回数据,而B语句需要先查询name字段的二级索引,然后再查询聚集索引,也就是需要进行回表查询

2. InnoDB主键索引的B+tree高度为多高呢?

![MySQL中的B+树范例](../images/MySQL中的B+树范例.png)

假设:               
一行数据大小为1k,一页中可以存储16行这样的数据           
InnoDB的指针占用6个字节的空间,主键key即使为bigint,占用字节数为8            

如果高度为2:            
n * 8 + (n + 1) * 6 = 16 * 1024,算出n约为1170          
即根节点下的key最多有1170个,指针最多有1171个,即叶子节点最多有1171个               
1171 * 16 = 18736,也就是说,如果树的高度为2,则可以存储1.8万条左右的记录           

如果高度为3:                    
1171 * 1171 * 16 = 21939856                                        
也就是说,如果树的高度为3,则可以存储2200万条左右的记录

# 语法


# SQL性能分析


# 使用


# 设计原则