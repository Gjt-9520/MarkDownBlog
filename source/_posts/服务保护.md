---
title: "服务保护"
date: 2024-07-24
description: ""
cover: https://github.com/Gjt-9520/Resource/blob/main/Bimage-135/Bimage72.jpg?raw=true
tags: ["SpringCloud","Sentinel"]
category: "微服务"
updated: 2024-07-25
  
top_group_index: 
---

# 雪崩问题

微服务调用链路中的某个服务故障,引起整个链路中的所有微服务都不可用,就是雪崩

雪崩问题产生的原因:
- 微服务相互调用,服务提供者出现故障或阻塞
- 服务调用者没有做好异常处理,导致自身故障
- 调用链中的所有服务级联失败,导致整个集群故障 

解决问题的思路:
1. 尽量避免服务出现故障或阻塞
- 保证代码的健壮性
- 保证网络畅通
- 能应对较高的并发请求
2. 服务调用者做好远程调用异常的后备方案,避免故障扩散

# 服务保护方案

- 请求限流:限制访问微服务的请求的并发量,避免服务因流量激增出现故障
- 线程隔离:也叫做舱壁模式,模拟船舱隔板的防水原理,通过限定每个业务能使用的线程数量而将故障业务隔离,避免故障扩散
- 服务熔断:由**断路器**统计请求的异常比例或慢调用比例,如果超出阈值则会**熔断**该业务,拦截该业务的请求,熔断期间,所有请求快速失败,全都走fallback逻辑
- 失败处理:给业务编写一个调用失败时的处理的逻辑,称为fallback,当调用出现故障(比如无线程可用)时,按照失败处理逻辑执行业务(返回默认数据或友好提示)并返回,而不是直接抛出异常

# 服务保护技术

![服务保护技术](../images/服务保护技术.png)

# Sentinel

Sentinel是阿里巴巴开源的一款微服务流量控制组件

[Sentinel官方网址](https://sentinelguard.io/zh-cn/index.html)

## 搭建

下载jar包后,通过如下命令启动Sentinel控制台:

```cmd
java -Dserver.port=8090 -Dcsp.sentinel.dashboard.server=localhost:8090 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar
```

## 微服务整合

1. 引入Maven依赖

```xml
<!--sentinel-->
<dependency>
    <groupId>com.alibaba.cloud</groupId> 
    <artifactId>spring-cloud-starter-alibaba-sentinel</artifactId>
</dependency>
```

2. 配置控制台

application.yaml:

```yaml
spring:
  cloud: 
    sentinel:
      transport:
        dashboard: localhost:8090
```

## 簇点链路

**簇点链路**,就是单机调用链路,是一次请求进入服务后经过的每一个被Sentinel监控的资源链

默认Sentinel会监控SpringMVC的每一个Endpoint(http接口)

限流、熔断等都是针对簇点链路中的**资源**设置的,而资源名默认就是接口的请求路径

Restful风格的API请求路径一般都相同,这会导致簇点资源名称重复,因此要修改配置,把请求方式+请求路径作为簇点资源名称:

```yaml
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8090
      http-method-specify: true # 开启请求方式前缀
```

## 请求限流

请求限流:限制访问微服务的请求的并发量,避免服务因流量激增出现故障

Sentinel控制台 --> 簇点链路 --> 流控 --> 设置QPS阈值

## 线程隔离

线程隔离:也叫做舱壁模式,模拟船舱隔板的防水原理,通过限定每个业务能使用的线程数量而将故障业务隔离,避免故障扩散

Sentinel控制台 --> 簇点链路 --> 流控 --> 设置线程数阈值

## 失败处理(Fallback)

给业务编写一个调用失败时的处理的逻辑,称为Fallback,当调用出现故障(比如无线程可用)时,按照失败处理逻辑执行业务(编写失败后的降级逻辑:返回默认数据或友好提示)并返回,而不是直接抛出异常

触发限流或熔断后的请求不一定要直接报错,也可以返回一些默认数据或者友好提示,用户体验会更好

给FeignClient编写失败后的降级逻辑有两种方式:
- 方式一:FallbackClass,无法对远程调用的异常做处理
- 方式二:FallbackFactory,可以对远程调用的异常做处理,**一般选择这种方式**

### 方式二

1. 在hm-api模块中给ItemClient定义降级处理类,实现FallbackFactory

ItemClientFallbackFactory.java:

```java
package com.hmall.api.client.fallback;

import com.hmall.api.client.ItemClient;
import com.hmall.api.dto.ItemDTO;
import com.hmall.api.dto.OrderDetailDTO;
import com.hmall.common.utils.CollUtils;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.openfeign.FallbackFactory;

import java.util.Collection;
import java.util.List;

@Slf4j
public class ItemClientFallbackFactory implements FallbackFactory<ItemClient> {
    @Override
    public ItemClient create(Throwable cause) {
        return new ItemClient() {
            @Override
            public List<ItemDTO> queryItemByIds(Collection<Long> ids) {
                log.error("查询商品失败:", cause);
                return CollUtils.emptyList();
            }

            @Override
            public void deductStock(List<OrderDetailDTO> items) {
                log.error("扣减商品库存失败:", cause);
                throw new RuntimeException(cause);
            }
        };
    }
}
```

2. 在hm-api模块中的com.hmall.api.config.DefaultFeignConfig类中将ItemClientFallback注册为一个Bean

```java
@Bean
public ItemClientFallbackFactory itemClientFallbackFactory(){
    return new ItemClientFallbackFactory();
}
```

3. 在hm-api模块中的ItemClient接口中使用ItemClientFallbackFactory

```java
package com.hmall.api.client;

import com.hmall.api.client.fallback.ItemClientFallbackFactory;
import com.hmall.api.dto.ItemDTO;
import com.hmall.api.dto.OrderDetailDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.Collection;
import java.util.List;

@FeignClient(value = "item-service", fallbackFactory = ItemClientFallbackFactory.class)
public interface ItemClient {
    @GetMapping("/items")
    List<ItemDTO> queryItemByIds(@RequestParam("ids") Collection<Long> ids);

    @PutMapping("/items/stock/deduct")
    void deductStock(@RequestBody List<OrderDetailDTO> items);
}
```

4. 开启OpenFeign的Sentinel监控

application.yaml:

```yaml
feign:
  okhttp:
    enabled: true # 开启OKHttp连接池支持
  sentinel:
    enabled: true # 开启Sentinel监控
```

## 服务熔断                 

**熔断是解决雪崩问题的重要手段**

服务熔断:由**断路器**统计请求的异常比例或慢调用比例,如果超出阈值则会**熔断**该业务,即拦截访问该服务的一切请求;而当服务恢复时,断路器会放行访问该服务的请求

熔断期间,所有请求快速失败,全都走fallback逻辑

![服务熔断](../images/服务熔断.png)

![断路器切换熔断状态](../images/断路器切换熔断状态.png)

Sentinel控制台 --> 簇点链路 --> 熔断 --> 设置熔断规则