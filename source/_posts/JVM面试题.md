---
title: "JVM面试题"
date: 2024-09-04
description: ""
cover: https://github.com/Gjt-9520/MarkDownBlog/blob/main/source/coverImages/Bimage-135/Bimage120.jpg?raw=true
tags: ["JVM"]
category: "面试"
updated: 2024-09-05
  
top_group_index: 
---

# JVM组成

## 什么是JVM？

JVM，Java Virtual Machine，Java虚拟机：Java程序的运行环境（Java二进制字节码的运行环境）。

好处：

1. 一次编写，到处运行

2. 自动内存管理，垃圾回收机制

## JVM内存区域的划分？

1. 堆：存储对象实例和数组

2. 虚拟机栈：存储局部变量和方法调用

3. 方法区：存储类的信息、运行时常量池

4. 程序计数器：记录正在执行的字节码指令的地址

5. 本地方法栈：和虚拟机栈类似，为本地方法服务

## 什么是程序计数器？

PC Register，程序计数器：线程私有的，每个线程一份，内部保存字节码的行号。用于记录正在执行的字节码指令的地址。

## 详细介绍一下堆？

Heap，堆：线程共享的区域，主要用来保存对象实例、数组等，内存不够的时候会抛出OOM。

组成：新生代+老年代。

新生代被划分为三部分，Eden区和两个大小严格相同的Survivor区（from和to）。

老年代主要保存生命周期长的对象，一般是一些老的对象。

## JDK1.7和JDK1.8中，堆的区别？

JDK1.7中有一个永久代，主要保存类的信息、静态变量、常量和编译后的代码。

JDK1.8移除了永久代，把这些数据保存到了本地内存中的元空间，防止OOM。

## 什么是虚拟机栈？

Java Virtual Machine Stacks，Java虚拟机栈。虚拟机栈一般用来存储局部变量和方法调用。

1. 每个线程运行时需要的内存，称为虚拟机栈，是先进后出的（FILO）。

2. 每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存。

3. 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。

## 垃圾回收是否涉及栈内存？

垃圾回收主要指的是堆内存，当栈帧弹栈以后，内存就会释放。

## 栈内存分配越大越好吗？

未必，默认分配的栈内存为1024K，即1M。

每个线程都会创建一个虚拟机栈，如果栈内存过大，会导致线程数变少。

例如机器总内存为512M，即目前能活动的线程数为512个，如果栈内存改为2048K，则线程数就会减半。

## 方法内的局部变量是否是线程安全的？

如果方法内的局部变量没有逃离方法的作用范围，它就是线程安全的。

如果局部变量引用了对象并逃离了方法的作用范围，它就不是线程安全的。例如，局部变量通过方法参数传递或者作为返回值。

## 栈内存溢出情况有哪些？

1. 栈帧过多导致栈内存溢出。例如，递归调用。

2. 栈帧过大导致内存溢出。

## 堆和栈的区别？

1. 存储

堆内存一般用来存储对象实例和数组。

栈内存一般用来存储局部变量和方法调用。

2. 垃圾回收

堆会被GC回收，栈不会。

3. 线程

堆是线程共有的，栈是线程私有的。

4. 异常

堆内存不足，抛出OOM，OutOfMemoryError。

栈内存不足，抛出StackOverFlowError。

## 解释一下方法区（元空间）？

Method Area，方法区（元空间）：是各个线程共享的内存区域。

主要存储类的信息、运行时常量池。

虚拟机启动时创建，关闭虚拟机时释放。

如果方法区中的内存无法满足分配请求时，会抛出OOM。

## 常量池、运行时常量池是什么？

常量池可以看作一张表，虚拟机指令根据这张常量表，找到要执行的类名、方法名、参数类型、字面量等信息。

常量池是*.class文件中的，当类被加载时，其常量池信息就会被放入运行时常量池，并把里面的符号地址变为真实地址。

## 你听说过直接内存吗？

直接内存不属于JVM的内存结构，不由JVM进行管理。是虚拟机的系统内存。

常见于NIO操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受JVM内存回收管理。

# 类加载器

## 什么是类加载器，有哪些？

JVM只会运行二进制文件，类加载器的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。

1. 启动类加载器

BootStrap ClassLoader：load from JAVA_HOME/jre/lib

由C++编写实现。

2. 扩展类加载器

ExtClassLoader：load from JAVA_HOME/jre/lib/ext

3. 应用类加载器：加载开发者自己编写的Java类

AppClassLoader：load from CLASSPATH

4. 自定义类加载器：自定义继承ClassLoader，实现自定义类加载规则

CustomizeClassLoader

## 什么是双亲委派模型？

加载某一个类，先委托上级的加载器进行加载，如果该类委托上级没有被加载，子加载器才会尝试加载该类。

## JVM为什么采用双亲委派机制？

1. 通过双亲委派机制可以避免一个类被重复加载。当父类已经加载后，则无需重复加载，保证唯一性。

2. 为了安全，保证类库API不会被修改。

## 类加载的执行过程？

1. 加载

查找和导入class文件。

方法区存储类的信息，堆存储对象实例。

2. 验证（连接）

验证类是否符合JVM规范，安全性检查。

文件格式验证：文件格式是否错误。

元数据验证：语法是否错误。

字节码验证：字节码是否合规。

符号引用验证：检查常量池里符号地址记录的将要使用的其他类或者方法，是否存在。

3. 准备（连接）

为类变量分配内存并设置类变量的初始值。

static变量，分配空间在准备阶段设置默认值，赋值在初始化阶段完成。

static变量是final的基本类型，以及字符串常量，值已经确定，赋值在准备阶段完成。

static变量是final的引用类型，分配空间在准备阶段设置默认值，赋值在初始化阶段完成。

4. 解析（连接）

把类中的符号引用转换为直接引用。

即运行时常量池把符号地址变为真实地址。

5. 初始化

对类的静态变量、静态代码块执行初始化操作。

如果初始化一个类的时候，其父类尚未初始化，先初始化其父类。

如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。

子类访问父类的静态变量，只会触发父类初始化。

6. 使用

JVM从入口方法开始执行用户的程序代码。

使用静态类成员变量，例如静态变量、静态方法。

使用new关键字为其创建对象实例。

7. 卸载

当用户程序代码执行完毕后，JVM开始销毁创建的Class对象。

# 垃圾回收

GC，Garbage Collection，垃圾回收。

## 对象什么时候可以被垃圾器回收？

如何一个或多个对象没有任何的引用指向它了，这个对象现在就是垃圾，如果定位了垃圾，就可能被垃圾回收器回收。

## 垃圾回收器怎么定位垃圾？

1. 引用计数法

一个对象被引用了一次，在当前对象头上递增一次引用次数，如果这个对象的引用次数为0，代表这个对象可回收。

问题：当对象间出现了循环引用的话，则引用计数法就会失效，会引发OOM。

2. 可达性分析算法

JVM中的垃圾回收器采用可达性分析来探索所有存活的对象，看能否沿着GC Root对象为起点的引用链找到该对象，找不到，代表这个对象可回收。

## 哪些对象可以作为GC Root？

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象

2. 方法区中类静态属性引用的对象

3. 方法区中常量引用的对象

4. 本地方法栈中JNI（即Native方法）引用的对象

## JVM垃圾回收算法有哪些？

1. 标记清除算法

垃圾回收分为2个阶段：标记和清除。

优点：标记和清除速度较快。

缺点：碎片化严重，内存不连贯。

2. 标记整理算法（老年代GC多使用）

和标记清除算法一样，将存活对象都向内存的另一端移动，然后清理边界以外的垃圾。

优点：解决了碎片化严重，内存不连贯的问题。

缺点：性能受到一定的影响。

3. 复制算法（新生代GC多使用）

将原有的内存空间一分为二，每次只用其中的一块，把正在使用的对象复制到另一个内存空间中。

优点：在垃圾多的情况下，效率高，清理后，内存无碎片。

缺点：分配的2块内存空间，在同一时刻，只能使用一半，内存使用效率低。

## 说一下JVM中的分代回收？

堆中划分为新生代和老年代，划分比例是1：2。

新生代：被划分成了3个区域，1个Eden区域、2个Survivor区域（from和to），划分比例是8：1：1。

分代回收策略：

1. 新创建的对象，会先分配到Eden区域

2. 当Eden区域内存不足时，GC会标记Eden区域和from（现阶段没有存活对象）区域中的存活对象

3. GC通过复制算法将存活对象移动到to区域中，然后释放Eden区域和from区域的内存

4. 经过一段时间后，Eden区域内存有不足时，GC会标记Eden区域和to区域中的存活对象

5. GC通过复制算法将存活对象移动到from区域中，然后释放Eden区域和to区域的内存

6. 如果存活对象经过了多次回收（最多15次），GC会将存活对象移动到老年代（新生代内存不足或者存活对象是大对象，会提前移动）。

## Minor GC、Mixed GC、Full GC的区别？

Minor GC：新生代的垃圾回收，STW短。

Mixed GC：新生代+老年代部分区域的垃圾回收，G1收集器特有。

Full GC：新生代+老年代的完整垃圾回收，STW长，应尽力避免。

STW，Stop The World，暂停时间：暂停所有应用程序线程，等待垃圾回收完成。

## JVM有哪些垃圾回收器？

1. 串行垃圾收集器

串行垃圾收集器，是指采用单线程进行垃圾回收，堆内存较小，适合个人电脑。

垃圾回收时，只有一个线程在工作，并且Java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

Serial：作用于新生代，采用复制算法。

Serial Old：作用于老年代，采用标记整理算法。

2. 并行垃圾收集器

并行垃圾收集器，JDK8默认使用。

垃圾回收时，多个线程在工作，并且Java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。

Parallel New：作用于新生代，采用复制算法。

Parallel Old：作用于老年代，采用标记整理算法。

3. CMS（并发）垃圾收集器

CMS，Concurrent Mark Sweep，是一款并发的、使用标记清除算法的垃圾回收器，作用于老年代。

特点：在进行垃圾回收时，应用仍能正常运行。

4. G1垃圾收集器

作用于新生代和老年代。

## 聊一下G1垃圾回收器？

应用于新生代和老年代，在JDK9之后默认使用G1。

划分多个区域，每个区域都可以充当eden、survivor、old、humongous。

采用复制算法。

响应时间与吞吐量兼顾。

分成三个阶段：新生代回收（STW）、并发标记（重新标记STW）、混合收集。

如果并发失败（即回收速度赶不上创建新对象的速度），会触发Full GC。

## 强引用、软引用、弱引用、虚引用的区别？

1. 强引用

只有所有的GC Roots对象都不通过强引用引用该对象，该对象才能被垃圾回收。


```java
User user = new User();
```

2. 软引用

仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收。

也可以配合引用队列使用。

```java
User user = new User();
SoftReference softReference = new SoftReference(user);
```

3. 弱引用

仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象。

也可以配合引用队列使用。

```java
User user = new User();
WeakReference weakReference = new WeakReference(user);
```

4. 虚引用

必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。

```java
User user = new User();
ReferenceQueue referenceQueue = new ReferenceQueue();
PhantomReference phantomReference = new PhantomReference(user,queue);
```

# JVM实践

## JVM调优的参数可以在哪里设置参数值？

1. war包部署在tomcat中设置

修改TOMCAT_HOME/bin/catalina.sh文件

JAVA_OPTS="-Xms512m -Xmx1024m"

2. jar包部署在启动参数设置

nohup java -Xms512m -Xmx1024m -jar xxxx.jar &

nohup：用于系统后台不挂断地运行命令，退出终端不会影响程序的运行。

参数&：让命令在后台执行，终端退出后，命令仍旧运行。

## JVM调优的参数有哪些？

1. 设置堆空间的大小

最大大小的默认值是物理内存的1/4，初始大小的默认值是物理内存的1/64。

通常把初始大小、最大大小设置为相同的值，防止垃圾收集器在初始大小和最大大小之间收缩堆而产生额外的时间。

不指定单位，默认为字节；指定单位，按照指定的单位设置。

`-Xms:1024`：设置堆的初始大小为1024字节

`-Xmx:1024m`：设置堆的最大大小为1024m

堆太小，可能会频繁的导致新生代和老年代的垃圾回收，会产生STW，暂停用户线程。

堆太大，也存在风险，如果发生了Full GC，它会扫描整个堆空间，暂停用户线程的时间长。

设置参考推荐：尽量大，综合考虑其他程序的内存使用情况。

2. 虚拟机栈的设置

每个线程默认会开启1M的内存，一般设置256k、512k。

`Xss:256k`:设置虚拟机栈的大小为256k

3. 新生代中eden和survivor的大小比例

`-XXSurvivorRatio=5`：新生代中的分配survivor：eden=2：5

4. 新生代晋升老年代阈值

默认为15，取值范围0~15

`-XX:MaxTenuringThreshold=10`：阈值为10

5. 设置垃圾回收收集器

通过增大吞吐量提高系统性能，可以通过设置并行垃圾回收收集器。

`-XX：+UseG1GC`：使用G1的垃圾回收收集器

## JVM的调优工具有哪些？

1. 命令行

`jps`：查看进程状态信息。

`jstack pid`：查看Java进程内线程的堆栈信息。

`jmap`：查看堆转内存快照、内存使用情况。

`jmap -heap pid`：显示Java堆的信息。

`jmap -dump:format=b,file=d:/heap.hprof pid`：在D盘为当前pid线程生成名为heap.hprof的内存快照文件。

`jhat`：堆转储快照分析工具。

`jstat`：JVM统计监测工具。

`jstat -gcutil pid`：总结垃圾回收统计。

`jstat -gc pid`：垃圾回收统计。

2. 可视化工具

jconsole：用于对JVM的内存、线程、类的监控。

jvisualvm：监控线程、内存情况。

## Java内存泄漏的排查思路？

方法区出现OutOfMemoryError:Metaspace

虚拟机栈出现StackOverFlowError

堆出现OutOfMemory:java heap space

内存泄漏通常指堆内存，一般是一些大对象不被回收的情况。

思路：

1. 使用jmap命令/vm参数，获取堆内存快照dump

使用jmap命令获取运行中程序的dump文件：`jmap -dump:format=b,file=d:/heap.hprof pid`

使用vm参数直接获取dump文件（无需程序在运行中）：`-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/app/dumps/`

2. 使用jvisualvm分析dump文件，查看对快照信息

3. 通过查看堆信息的情况，大概定位内存溢出是哪行代码出了问题

## CPU飙高的排查方案及思路？

1. 使用top命令查看CPU的情况

2. 查看哪一个进程占用CPU较高，记住其pid

3. 通过命令`ps H -eo pid,tid,%cpu | grep pid`，根据进程找到线程的信息

4. 可以根据tid找到有问题的线程，进一步定位到问题代码的源代码行号

`printf "%x\n" tid`：将tid由10进制转换为16进制

`jstack pid`：查看Java进程内线程的堆栈信息