---
title: "设计模式面试题"
date: 2024-09-06
description: ""
cover: https://github.com/Gjt-9520/MarkDownBlog/blob/main/source/coverImages/Bimage-135/Bimage122.jpg?raw=true
tags: ["JavaSE"]
category: "面试"
updated: 2024-09-07
  
top_group_index: 
---

# 工厂模式

开闭原则：对扩展开放，对修改关闭

优点：解耦

## 简单工厂模式

简单工厂模式的主要角色：

1. 抽象产品：定义了产品的规范，描述了产品的主要特性和功能

2. 具体产品：实现或集成抽象产品的子类

3. 具体工厂：提供创建产品的方法，调用者通过该方法来获取产品

## 工厂方法模式

工厂方法模式的主要角色：

1. 抽象工厂（AbstractFactory）：提供创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品

2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建

3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能

4. 具体产品（ConcreteProduct）：实现了抽象产品所定义的接口，由具体工厂来创建，它通具体工厂之间一一对应

优点：

用户只需要知道具体工厂的名称就可以得到所要的产品，无须直到产品的具体创建过程

在系统增加新的产品时，只要添加具体产品类和对应的具体工厂类，无需对原工厂进行任何修改，满足开闭原则

缺点：

每增加一个产品就增加一个具体产品类和一个对应的具体工厂类，增加了系统的复杂度

## 抽象工厂模式

产品族：一个品牌下面的所有产品

产品等级：多个品牌下面的同种产品

工厂方法模式只考虑生产同等级的产品，抽象工厂可以生产多个等级的产品

一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂

优点：

当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象

缺点：

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改

# 策略模式

策略模式定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户

一个系统需要动态地在这几种算法中选择一种时，可以将每个算法封装到策略类中

策略模式的主要角色：

1. 抽象策略类（Strategy）：这是一个抽象角色，通常由一个接口或抽象类实现，此角色给出所有的具体策略类所需要的接口

2. 具体策略类（ConcreteStrategy）：实现了抽象策略定义的接口，提供具体的算法实现或行为

3. 环境类（Context）：持有一个策略类的引用，最终给客户端调用

优点：

策略类之间可以切换

易于扩展

避免使用多重条件选择语句，充分体现面向对象设计思想

缺点：

客户端必须知道所有的策略类，并自行决定使用哪一个策略类

策略模式将造成产生很多策略类

# 责任链模式

责任链模式主要角色：

1. 抽象处理者（Handler）：定义一个处理请求的抽象类，包含抽象处理方法和一个后继连接

2. 具体处理者（Concrete Handler）：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理；否则将该请求转给它的后继者

3. 客户类（Client）：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程

优点：

降低了对象之间的耦合度

增强了系统的可拓展性

增强了给对象指派职责的灵活性

责任链简化了对象之间的连接

责任分担

缺点：

对比较长的责任链，请求的处理可能涉及多个处理对象，系统性能将受到一定的影响

责任链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于责任链的错误设置而导致系统出错，例如可能会造成循环调用


