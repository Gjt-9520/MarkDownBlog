---
title: "设计模式面试题"
date: 2024-09-06
description: ""
cover: https://github.com/Gjt-9520/MarkDownBlog/blob/main/source/coverImages/Bimage-135/Bimage122.jpg?raw=true
tags: ["JavaSE"]
category: "面试"
updated: 2024-09-07
  
top_group_index: 
---

# 工厂模式

开闭原则：对扩展开放，对修改关闭

优点：解耦

## 简单工厂模式

简单工厂模式的主要角色：

1. 抽象产品：定义了产品的规范，描述了产品的主要特性和功能

2. 具体产品：实现或集成抽象产品的子类

3. 具体工厂：提供创建产品的方法，调用者通过该方法来获取产品

## 工厂方法模式

工厂方法模式的主要角色：

1. 抽象工厂（AbstractFactory）：提供创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品

2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建

3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能

4. 具体产品（ConcreteProduct）：实现了抽象产品所定义的接口，由具体工厂来创建，它通具体工厂之间一一对应

优点：

用户只需要知道具体工厂的名称就可以得到所要的产品，无须直到产品的具体创建过程

在系统增加新的产品时，只要添加具体产品类和对应的具体工厂类，无需对原工厂进行任何修改，满足开闭原则

缺点：

每增加一个产品就增加一个具体产品类和一个对应的具体工厂类，增加了系统的复杂度

## 抽象工厂模式

产品族：一个品牌下面的所有产品

产品等级：多个品牌下面的同种产品

工厂方法模式只考虑生产同等级的产品，抽象工厂可以生产多个等级的产品

一个超级工厂创建其他工厂，该超级工厂又称为其他工厂的工厂

优点：

当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象

缺点：

当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改

# 策略模式

策略模式定义了一系列的算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户

一个系统需要动态地在这几种算法中选择一种时，可以将每个算法封装到策略类中

策略模式的主要角色：

1. 抽象策略类（Strategy）：这是一个抽象角色，通常由一个接口或抽象类实现，此角色给出所有的具体策略类所需要的接口

2. 具体策略类（ConcreteStrategy）：实现了抽象策略定义的接口，提供具体的算法实现或行为

3. 环境类（Context）：持有一个策略类的引用，最终给客户端调用

优点：

策略类之间可以切换

易于扩展

避免使用多重条件选择语句，充分体现面向对象设计思想

缺点：

客户端必须知道所有的策略类，并自行决定使用哪一个策略类

策略模式将造成产生很多策略类

# 责任链模式

